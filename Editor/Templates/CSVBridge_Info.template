// AUTOGENERATED FILE
// DO NOT MODIFY DIRECTLY
using System;
using System.Collections.Generic;
using System.IO;
using PocketGems.Parameters.Editor.LocalCSV;
using PocketGems.Parameters.LocalCSV;
using PocketGems.Parameters.Util;
using UnityEditor;
using UnityEngine;

namespace {{namespace}}
{
#if !{{disableSymbol}}
    public partial class {{className}}
    {
        private static void DefineSchema{{interface.BaseName}}(CSVFile csvFile)
        {
            string[] columnNames = {
            {{~for name in interface.CSVColumnNames~}}
                "{{name}}",
            {{~end~}}
            };
            string[] columnTypes = {
            {{~for type in interface.CSVColumnTypes~}}
                "{{type}}",
            {{~end~}}
            };
            csvFile.DefineSchema(columnNames, columnTypes);
        }

        private void CheckSchema{{interface.BaseName}}(CSVFile csvFile)
        {
            _currentCSVFile = csvFile;
            string[] columnNames = {
            {{~for name in interface.CSVColumnNames~}}
                "{{name}}",
            {{~end~}}
            };
            string[] columnTypes = {
            {{~for type in interface.CSVColumnTypes~}}
                "{{type}}",
            {{~end~}}
            };
            try
            {
                csvFile.CheckSchema(columnNames, columnTypes);
            }
            catch (Exception e)
            {
                SaveReadError(e.Message);
            }
        }

        private void Read{{interface.BaseName}}()
        {
            if (_scriptableObjectMetadatas == null)
                return;
            var keyPathBuilder = new StructKeyPathBuilder();
            var csvFile = _infoCSVFileCache.Load<{{interface.InterfaceName}}>();
            _currentCSVFile = csvFile;
            for (int i = 0; i < _scriptableObjectMetadatas.Count; i++)
            {
                try
                {
                    _currentGUID = null;
                    _currentIdentifier = null;
                    _currentPropertyName = null;
                    _currentStructPath = null;
                    var metadata = _scriptableObjectMetadatas[i];
                    var guid = metadata.GUID;
                    _currentGUID = guid;
                    var csvRow = csvFile.GetOrCreateRow(guid);
                    _currentIdentifier = csvRow.Identifier;
                    var data = metadata.ScriptableObject as {{interface.DataObjectName}};
                    // push the csvRow.Identifier since the current data.name might be renamed
                    keyPathBuilder.PushRootKey("{{interface.BaseName}}", csvRow.Identifier);
                    var filePath = metadata.FilePath;
                    var rowData = csvRow.Data;
            {{~for propertyType in interface.PropertyTypeDicts~}}
                    _currentPropertyName = "{{propertyType.PropertyName}}";
                {{~lines = propertyType.CSVBridgeReadFromCSVSource | regex.split `\n`~}}
                {{~for line in lines~}}
                    {{line}}
                {{~end~}}
            {{~end~}}
                    keyPathBuilder.PopKey();
                }
                catch (Exception e)
                {
                    SaveReadError(e.Message);
                    keyPathBuilder.Clear();
                }
            }
        }

        private void Update{{interface.BaseName}}()
        {
            var csvFile = _infoCSVFileCache.Load<{{interface.InterfaceName}}>();
            if (_scriptableObjectMetadatas == null)
                return;
            var structCSVFileCache = _structCSVFileCache;
            var keyPathBuilder = new StructKeyPathBuilder();
            for (int i = 0; i < _scriptableObjectMetadatas.Count; i++)
            {
                var metadata = _scriptableObjectMetadatas[i];
                var data = metadata.ScriptableObject as {{interface.DataObjectName}};
                var guid = metadata.GUID;
                keyPathBuilder.PushRootKey("{{interface.BaseName}}", data.name);
                string[] rowData = new string[{{interface.PropertyTypeDicts.size}}];
        {{~for propertyType in interface.PropertyTypeDicts~}}
            {{~lines = propertyType.CSVBridgeUpdateCSVRowSource | regex.split `\n`~}}
            {{~for line in lines~}}
                {{line}}
            {{~end~}}
        {{~end~}}
                var csvRow = csvFile.GetOrCreateRow(guid);
                csvRow.GUID = guid;
                csvRow.UpdateData(rowData);

                keyPathBuilder.PopKey();
            }
        }
    }
#endif
}
