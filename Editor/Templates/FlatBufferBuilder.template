// AUTOGENERATED FILE
// DO NOT MODIFY DIRECTLY
using System;
using System.Collections.Generic;
using System.IO;
using FlatBuffers;
using PocketGems.Parameters.Models;
using UnityEngine;

namespace {{namespace}}
{
#if !{{disableSymbol}}
    public partial class {{className}}
    {
        // invoked via reflection
        public static int Generate(string outputFile,
            string hash,
            Dictionary<Type, List<IScriptableObjectMetadata>> scriptableObjectMetadatas)
        {
            var builder = new {{className}}(hash, scriptableObjectMetadatas);
            builder.Build();
            return builder.WriteToFile(outputFile);
        }

        // data to write
        private readonly string _hash;
        private readonly Dictionary<Type, List<IScriptableObjectMetadata>> _scriptableObjectMetadatas;

        // building
        private readonly FlatBuffers.FlatBufferBuilder _builder;
        private readonly Dictionary<string, VectorOffset> _interfaceNameToVectorOffsets;
        private readonly Dictionary<string, List<object>> _structNameToOffsetStructs;

        // output
        private byte[] _buffer;

        private {{className}}(
            string hash,
            Dictionary<Type, List<IScriptableObjectMetadata>> scriptableObjectMetadatas)
        {
            _hash = hash;
            _scriptableObjectMetadatas = scriptableObjectMetadatas;
            _builder = new FlatBuffers.FlatBufferBuilder(1024);
            _interfaceNameToVectorOffsets = new Dictionary<string, VectorOffset>();
            _structNameToOffsetStructs = new Dictionary<string, List<object>>();
        }

        private void Build()
        {
            BuildScriptableObjectTables();
            BuildStructTables();
            BuildCollection();

            _buffer = _builder.SizedByteArray();
        }

        private void BuildScriptableObjectTables()
        {
            List<IScriptableObjectMetadata> metas;
        {{~for interface in infoInterfaces~}}
            if (_scriptableObjectMetadatas.TryGetValue(typeof({{interface.InterfaceName}}), out metas))
                Build{{interface.BaseName}}(metas);
        {{~end~}}
        }

        private void BuildStructTables()
        {
            // build the vector of structs after iterating through all Scriptable Objects where they're created.
        {{~for interface in structInterfaces~}}
            if (_structNameToOffsetStructs.ContainsKey("{{interface.InterfaceName}}"))
            {
                var offsetList = _structNameToOffsetStructs["{{interface.InterfaceName}}"];
                var offsets = new Offset<{{interface.FlatBufferStructName}}>[offsetList.Count];
                for (int i = 0; i < offsetList.Count; i++)
                    offsets[i] = (Offset<{{interface.FlatBufferStructName}}>)offsetList[i];
                var vectorOffset = {{collectionStructName}}.Create{{interface.FlatBufferStructName}}Vector(_builder, offsets);
                _interfaceNameToVectorOffsets["{{interface.InterfaceName}}"] = vectorOffset;
            }
        {{~end~}}
        }

        private void BuildCollection()
        {
            var hash = _builder.CreateSharedString(_hash);

            {{collectionStructName}}.Start{{collectionStructName}}(_builder);
            RootCollection.AddDataHash(_builder, hash);

            // add all info vectors to the collection
        {{~for interface in infoInterfaces~}}
            if (_interfaceNameToVectorOffsets.ContainsKey("{{interface.InterfaceName}}"))
                {{collectionStructName}}.Add{{interface.FlatBufferStructName}}(_builder, _interfaceNameToVectorOffsets["{{interface.InterfaceName}}"]);
        {{~end~}}

            // add all info struct vectors to the collection
        {{~for interface in structInterfaces~}}
            if (_interfaceNameToVectorOffsets.ContainsKey("{{interface.InterfaceName}}"))
                {{collectionStructName}}.Add{{interface.FlatBufferStructName}}(_builder, _interfaceNameToVectorOffsets["{{interface.InterfaceName}}"]);
        {{~end~}}

            var offset = {{collectionStructName}}.End{{collectionStructName}}(_builder);

            // finish the buffer with the root collection
            _builder.Finish(offset.Value);
        }

        private int WriteToFile(string outputFile)
        {
            var directoryPath = Path.GetDirectoryName(outputFile);
            if (!Directory.Exists(directoryPath))
                Directory.CreateDirectory(directoryPath);

            // write to file
            File.WriteAllBytes(outputFile, _buffer);

            return _buffer.Length;
        }
    }
#endif
}
