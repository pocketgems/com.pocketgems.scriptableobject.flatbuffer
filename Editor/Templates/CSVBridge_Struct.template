// AUTOGENERATED FILE
// DO NOT MODIFY DIRECTLY
using System;
using System.Collections.Generic;
using System.IO;
using PocketGems.Parameters.DataTypes;
using PocketGems.Parameters.Editor.LocalCSV;
using PocketGems.Parameters.Interface;
using PocketGems.Parameters.LocalCSV;
using PocketGems.Parameters.Util;
using UnityEditor;
using UnityEngine;

namespace {{namespace}}
{
#if !{{disableSymbol}}
    public partial class {{className}}
    {
        private static void DefineSchema{{interface.BaseName}}(CSVFile csvFile)
        {
            string[] columnNames = {
            {{~for name in interface.CSVColumnNames~}}
                "{{name}}",
            {{~end~}}
            };
            string[] columnTypes = {
            {{~for type in interface.CSVColumnTypes~}}
                "{{type}}",
            {{~end~}}
            };
            csvFile.DefineSchema(columnNames, columnTypes);
        }

        private void CheckSchema{{interface.BaseName}}(CSVFile csvFile)
        {
            _currentCSVFile = csvFile;
            string[] columnNames = {
            {{~for name in interface.CSVColumnNames~}}
                "{{name}}",
            {{~end~}}
            };
            string[] columnTypes = {
            {{~for type in interface.CSVColumnTypes~}}
                "{{type}}",
            {{~end~}}
            };
            try
            {
                csvFile.CheckSchema(columnNames, columnTypes);
            }
            catch (Exception e)
            {
                SaveReadError(e.Message);
            }
        }

        private {{interface.BaseName}} Read{{interface.BaseName}}({{interface.BaseName}} data, StructKeyPathBuilder keyPathBuilder)
        {
            try
            {
                var keyPath = keyPathBuilder.KeyPath();
                _currentStructPath = keyPath;
                var csvRow = _structCSVFileCache.LoadRow<{{interface.InterfaceName}}>(keyPath);
                var rowData = csvRow.Data;
                if (rowData != null)
                {
            {{~for propertyType in interface.PropertyTypeDicts~}}
                    _currentPropertyName = "{{propertyType.PropertyName}}";
                {{~lines = propertyType.CSVBridgeReadFromCSVSource | regex.split `\n`~}}
                {{~for line in lines~}}
                    {{line}}
                {{~end~}}
            {{~end~}}
                }
            }
            catch (Exception e)
            {
                SaveReadError(e.Message);
            }
            finally
            {
                _currentStructPath = null;
            }
            return data;
        }

        private {{interface.BaseName}}? AttemptRead{{interface.BaseName}}({{interface.BaseName}} data, StructKeyPathBuilder keyPathBuilder)
        {
            var keyPath = keyPathBuilder.KeyPath();
            var csvFile = _structCSVFileCache.Load<{{interface.InterfaceName}}>();
            if (!csvFile.HasRow(keyPath))
                return null;
            return Read{{interface.BaseName}}(data, keyPathBuilder);
        }

        private static void Update{{interface.BaseName}}(IStructCSVFileCache structCSVFileCache, {{interface.DataObjectName}} data, StructKeyPathBuilder keyPathBuilder)
        {
            var csvFile = structCSVFileCache.Load<{{interface.InterfaceName}}>();
            string[] rowData = new string[{{interface.PropertyTypeDicts.size}}];

    {{~for propertyType in interface.PropertyTypeDicts~}}
        {{~lines = propertyType.CSVBridgeUpdateCSVRowSource | regex.split `\n`~}}
        {{~for line in lines~}}
            {{line}}
        {{~end~}}
    {{~end~}}
            var guid = keyPathBuilder.KeyPath();
            var csvRow = csvFile.GetOrCreateRow(guid);
            csvRow.GUID = guid;
            csvRow.UpdateData(rowData);
        }
    }
#endif
}
